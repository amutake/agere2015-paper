\section{Syntax}

Actario では

以下のように定義する。

\begin{equation}
  configuration ::= multiset of in\_flight\_message \bowtie set of actor
  actor ::= Actor(name, actions, \mathbb{N})
  name ::= toplevel | generated(\mathbb{N}, name)
  actions ::= name ! message; actions
  | new behavior
\end{equation}


\subsection{Actor Name}
アクターの名前は、親がいないアクターと何らかのアクターから生成されたアクターに分けて定義する。
親がいないアクターは toplevel actor と呼ぶ。
これはアクターシステムに最初から存在するアクターを表す。
何らかのアクターから生成されたアクターを generated actor と呼ぶ。
generated actor の名前は、親アクターの名前と、その親アクターが何番目に生成した子かという番号 (generation number) のペアとする。
これは動的に生成されうるアクターの名前の一意性を保つためである。
基本的に Actario のプログラマは自分で名前を構築するようなことはしない。

\begin{lstlisting}
Inductive name : Set :=
| toplevel : string -> name
| generated : nat -> name -> name.
\end{lstlisting}

\subsection{message}
アクター間で取り交わされるメッセージの型を定義する。
Coq 内でメッセージを扱うため、Coq の型として定義する。
また、任意の型の値をメッセージとすることはできない。
これは、
1. これを導入すると name, 後述する actor, actions, behavior にメッセージの型パラメータを付与しなければいけなくなり、この後の証明が煩雑になる
2. ターゲットとして Erlang を想定しているので、Erlang のプリミティブをサポートするくらいでいい
3. この定義で十分
のためである。(理由が弱い)

\begin{lstlisting}
Inductive message : Set :=
| empty_msg : message
| name_msg : name -> message
| str_msg : string -> message
| nat_msg : nat -> message
| bool_msg : bool -> message
| tuple_msg : message -> message -> message.
\end{lstlisting}

\subsection{actions, behavior}
\texttt{actions} はアクターが行うアクションの列である。new, send, self, become がある。
behavior is a function from message to actions.

\begin{lstlisting}
CoInductive actions : Type :=
| new : behavior -> (name -> actions) -> actions
| send : name -> message -> actions -> actions
| self : (name -> actions) -> actions
| become : behavior -> actions
with behavior : Type :=
| receive : (message -> actions) -> behavior.
\end{lstlisting}

actions のそれぞれのコンストラクタを説明する。
\texttt{new : behavior -> (name -> actions) -> actions} は、新しいアクターを生成するアクションである。
引数として与えられたある behavior を initial behavior として新しいアクターを生成し、その名前をアクションの継続に渡す。
\texttt{send : name -> message -> actions -> actions} は、指定した名前のアクターにメッセージを送るアクションである。
第一引数に指定した名前のアクターに、第二引数で指定したメッセージを送り、第三引数で指定したその後のアクションを実行する、という意味である。
\texttt{self : (name -> actions) -> actions} は自分自身の名前を得るアクションである。
自分の名前を第一引数で与えられた継続に渡し、残りのアクションを得る。
\texttt{become : behavior -> actions} は次のメッセージに対して指定した振る舞いで処理する。
また、次のメッセージの待ち状態になることも表し、これ以降アクションは取れないようになっている。

actions と behavior は co-inductive types として定義される。
これは become で現在の behavior を指定したり、ある他の behavior と相互再帰するようなことがあるからである。
Coq ではこのような、コンストラクタの深さが小さくならない再帰は通常の inductive definition では書けなくなっている。

また、以下のように notation をつけている。

\begin{lstlisting}
Notation ``n '<-' 'new' behv ; cont'' := (new behv (fun n => cont)) (at level 0, cont at level 10).
Notation ``n '!' m ';' a'' := (send n m a) (at level 0, a at level 10).
Notation ``me '<-' 'self' ';' cont'' := (self (fun me => cont)) (at level 0, cont at level 10).
\end{lstlisting}

\texttt{n <- new behv; cont} は \texttt{new behv (fun n => cont)} に変換され、
\texttt{n ! msg; cont} は \texttt{send n msg cont} に変換され、
\texttt{me <- self; cont} は \texttt{self (fun me => cont)} に変換される。

\subsection{actor}
アクターは、自分自身名前、残りのアクションの列、次回アクターを生成する際に使う generation number の3つのレコード型である。
残りのアクションの列が become のみの場合、このアクターはメッセージを受け取れる状態にあるということを表す。

\begin{lstlisting}
Record actor := {
  actor_name : name;
  remaining_actions : actions;
  next_num : gen_number
}.
\end{lstlisting}

\subsection{in flight message}
宛先と送り主とメッセージの内容からなるレコード型である。
まだ受け取られていないメッセージを表す。
configuration に用いる。

\subsection{configuration}
actor の列と in\_flight\_message の列のペア

\footnote{seq は ssreflect で定義されているもので、Coq の list の notation。}

\subsection{Example: factorial system}
例として階乗を計算するアクターシステムを定義する。

\begin{lstlisting}
CoFixpoint factorial_cont_behv (val : nat) (cust : name) : behavior :=
  receive (fun msg =>
         match msg with
           | nat_msg arg =>
             cust ! nat_msg (val * arg);
             become empty_behv
           | _ => become (factorial_cont_behv val cust)
         end).

CoFixpoint factorial_behv : behavior :=
  receive (fun msg =>
         match msg with
           | tuple_msg (nat_msg 0) (name_msg cust) =>
             cust ! nat_msg 1;
             become factorial_behv
           | tuple_msg (nat_msg (S n)) (name_msg cust) =>
             cont <- new (factorial_cont_behv (S n) cust);
             me <- self;
             me ! tuple_msg (nat_msg n) (name_msg cont);
             become factorial_behv
           | _ => become factorial_behv
         end).

Definition factorial_system (n : nat) (parent : name) : config :=
  init "factorial" (
         x <- new factorial_behv;
         x ! tuple_msg (nat_msg n) (name_msg parent);
         become empty_behv
       ).
\end{lstlisting}
