\section{Introduction}
\label{sec:introduction}

The Actor model is a model of concurrent computation \cite{Agha:1986aa}.
Computation entity called \textit{actor} communicates other actors with asynchronous message passing.
アクターモデルは並行計算のモデルの一つである\cite{Agha:1986aa}。
アクターモデルではアクターと呼ばれる計算実体が非同期にメッセージを送り合うことで計算を進める。
あるアクターがメッセージに対してどういう動作を行うか、ということをそのアクターの振る舞いという。
アクターはメッセージを受け取ると、新しいアクターを作る、他のアクターにメッセージを送る、自分自身の振る舞いを変える、という3つの動作を行うことができる。

アクターモデルに基づく言語は多数提案・実装されてきており、それらの研究成果をもとに現在 Erlang、Akka 等、アクターモデルを並行計算の基盤としたプログラミング言語やライブラリが実用に供されている。
そのため、アクターモデルに寄って構成されたシステムの形式的検証は喫緊の課題であると考えられる。

形式的検証については、アクターで記述されたシステムのモデル検査を可能にするモデル記述言語 Rebeca、
証明支援系 Athena を用いた形式化、
および Coq を用いたアクターモデルの定式化など、
最近になっていくつかの研究成果が出ている。

In the Actor model, actors send messages by specifying destination actor name, so that fresh naming of actor names is important.
In realistic actor languages and libraries, such as Erlang \cite{Erlang} and Scala \cite{Scala} Akka \cite{Akka}, It can generate actors without explicit naming by a programmer.
If the naming is explicit, sometimes it is difficult to guarantee name uniqueness in realistic and complex systems.

In this paper, we propose Actario, a Coq framework for implementing and verifying actor systems \cite{Actario}. Actario is publicly available.
To be close to realistic actor languages and libraries, we make Actario to generate actors without explicit naming, and to preserve consistency, we have proven that Actario satisfies name uniqueness.

The main features of Actario are the followings:

\begin{itemize}
\item Actario makes it possible to verify actor systems in Coq.
\item The Actario programmer can write actor systems like Erlang.
\item Actario can generate executable Erlang code.
\end{itemize}

Actario itself is verified for satisfying properties of the Actor model, the following properties:

\begin{itemize}
\item Actor names generated by the system are always unique.
\item Actors do not disappear from the system.
\item Messages do not disappear from the system except reception.
\end{itemize}

% 形式的検証をおこなう上での問題
% 特にアクターの名前の生成，一貫性

%% 特にアクターの名前の
%% アクターの名前は必ず一意である必要がある。
%% アクターはシステムの進行に伴って動的に生成されるが、その中で fresh でない名前の生成が行われることはない。
%% fresh なアクターの名前の付け方には、~がある。

% ここで解決したい問題は何か（問題）
% * アクターモデルは並行計算のモデルとして real world でよく使われている
% * 一般的に並行システムの検証は難しい
% * アクターシステム (アクターモデルで記述されたアプリケーション) の検証を行いたい
% Actarioではどのようにして問題を解決しようとしているか（手法）
% 提案手法
% * 名前付けの方法とそれによる名前の一貫性の形式的証明
% それによってどのようなことが明らかになるか：
% * 普通のプログラミングと同様にモデル化できる
% * 名前を勝手につけられるので検証は難しくなる(?)

% Actarioの特徴
% * 普通のプログラミングと同様にシステムを記述できる
% * Coqによって検証もできる
%   + 実装しているシステム自身はCoqによって検証されている
%     - 名前の一貫性（済）
%     - アクターのpersistence (済）
%     - メッセージのpersistence (済）
% * Erlangプログラムを生成できる

The layout of the rest of this paper is the following.
In Section~\ref{sec:overview}, we describe overview of Actario.
In Section~\ref{sec:semantics}, we give the operational semantics of the Actor model formalized in Actario.
In Section~\ref{sec:uniqueness}, we explain how to prove that dynamically generated names are always unique.
In Section~\ref{sec:fairness}, we formalize fairness property.
In Section~\ref{sec:extraction}, we describe extraction mechanism of Actario.
In Section~\ref{sec:relatedwork}, we show related work, and in Section~\ref{sec:conclusion}, we conclude the paper.

%% 2節では Actario で使うアクターのシンタックスを説明する。
%% 3節では Actario で用いるアクターモデルの意味論について説明する。
%% 4節では、Actario が用いる意味論において、動的に生成されるアクターの名前が一意になるという定理の証明を説明する。
%% 5節では Actario における fairness の定式化について説明し、
%% 6節で他のアクターモデルの形式化や並行・分散システムの検証用フレームワークとの差異を述べる。
