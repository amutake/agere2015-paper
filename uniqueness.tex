\section{Name Uniqueness}
\label{sec:uniqueness}
%% \note{なぜこれが証明されていなければいけないのか、これが証明されていることによってどういうことが言えるのか}
In programming languages or libraries providing the Actor model such as Erlang or Akka,
the system automatically generates actors with fresh names without specifying the name explicitly by the programmer.
In Actario, the proposition that all actor names in the configuration are not duplicate by any transitions is proven.

%% アクターモデルを提供する言語やライブラリ、例えば Erlang や Akka では、アクターを生成する際にプログラマが名前を指定せずとも fresh な名前を生成してくれる。
%% また、アクターはシステムの進行中に動的に生成されうるものなので、動的に生成されうるアクターの名前が常に一意になることが重要である。
%% Actario では、Actario の意味論において、ある制限を満たした初期状態からの任意の遷移でアクターの名前が衝突しないことを証明した。

To prove, we define an invariant about actor names preserved between any transitions. It is named \textit{trans invariant}.
The trans invariant consists of the following three predicates for configuration.
%% システムの遷移において満たされる、名前についての性質 trans invariant を定義し、trans invariant が確かに遷移の間で保存されることを証明、そして trans invariant が成り立てば名前の一意性が成り立つことの証明、初期状態が

\begin{displaymath}
  \begin{array}{l}
    \texttt{trans\_invariant}(c) := \\
    \quad \texttt{chain}(c) \wedge \texttt{gen\_fresh}(c) \wedge \texttt{no\_dup}(c)
  \end{array}
\end{displaymath}

The brief explanations of \texttt{chain}, \texttt{gen\_fresh}, and \texttt{no\_dup} are followings:

\begin{description}[style=nextline,leftmargin=12pt,parsep=0pt]
\item[\texttt{chain}]
  For each actor in the configuration, if the actor is generated by another actor, then the parent actor is also in the configuration.
\item[\texttt{gen\_fresh}]
  For each actor in the configuration, actor name genereted by the actor in the next is fresh.
\item[\texttt{no\_dup}]
  For all actor name in the configuration are unique.
\end{description}

\subsection{functions}

Before starting the explanation and the proof, we define some functions used in this section.

\begin{description}[style=nextline,leftmargin=12pt,parsep=0pt]
\item[\texttt{actors} $: \textit{Configuration} \rightarrow \textit{Set(Actor)}$]
  \texttt{actors} returns the set of actors in the given configuration.
\item[\texttt{parent} $: \textit{Actor} \rightarrow \textit{Actor}$]
  \texttt{parent} returns the parent actor of the given actor.
  If the given actor is toplevel actor, the function returns nothing. % null?
\item[\texttt{gen\_number} $: \textit{Actor} \rightarrow \mathbb{N}$]
  \texttt{gen\_number} returns generated number of the name of the given actor.
  If the given actor is toplevel actor, the function returns nothing.
\item[\texttt{next\_number} $: \textit{Actor} \rightarrow \mathbb{N}$]
  \texttt{next\_number} returns next generation number of the given actor.
\item[\texttt{name} $: \textit{Actor} \rightarrow \textit{Name}$]
  \texttt{name} returns the name of the given actor.
\item[\texttt{names} $: \textit{Set(Actor)} \rightarrow \textit{Set(Name)}$]
  \texttt{names} returns names of the given set of actors.
\end{description}

\subsection{chain}
We define a predicate of configuration, called \texttt{chain}.
\texttt{chain} is the predicate that, for each actor in the given configuration, if it is generated by another actor, the parent actor is also in the configuration.
\texttt{chain} is defined as the following.

\begin{displaymath}
  \begin{array}{l}
    \texttt{chain}(c) := \\
    \quad \forall a \in \texttt{actors}(c), \forall p, p = \texttt{parent}(a) \Rightarrow p \in \texttt{actors}(c)
  \end{array}
\end{displaymath}

Then, we can prove \textit{chain preservation property} that chain is preserved between any transitions.
The proof is by case analysis on the label.
\texttt{chain} is decided by only actor names, and the transition which have a possibility to change the names in the configuration is only \textsc{New} transition.
Therefore, we consider only the case of \textsc{New} transition.

\begin{lemma}{chain preservation}
\begin{displaymath}
  \begin{array}{l}
    \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
    \quad \texttt{chain}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \texttt{chain}(c')
  \end{array}
\end{displaymath}
\end{lemma}

\subsection{gen\_fresh}
We define \texttt{gen\_fresh} predicate that, for each actor in the configuration, the name of its child is always fresh.
The definition of \texttt{gen\_fresh} is complicated a little.
We translate the proposition that next generated name is fresh to the following.

\begin{displaymath}
  \begin{array}{l}
    \texttt{gen\_fresh}(c) := \\
    \quad \forall a \in \texttt{actors}(c), \forall p \in \texttt{actors}(c), p = \texttt{parent}(a) \Rightarrow \\
    \quad \quad \quad \texttt{gen\_number}(a) < \texttt{next\_number}(p)
  \end{array}
\end{displaymath}


It is guaranteed that the actor name generated in the next is fresh if satisfying \texttt{gen\_fresh} predicate by the relation of next generation numbers and actor names. %% For each actor in the configuration, if its parent is in the configuration, the next generation number of the parent actor is greater than the generation number of the name of the child actor.
However, the actor name generated after the next is not always fresh name.
For example, if there are two actors ($A$ and $B$) that have the same name and the same next generation number and actor $A$ generates a child actor and actor $B$ generates a child actor, although \texttt{gen\_fresh} holds, these child actors have the same name.
Furthermore, if the parent of the actor $A$ does not exist in the configuration and the parent of the parent exists in the configuration, and the parent of the parent actor generates an actor and it also generates an actor, then the name is possible to have the same as $A$'s one.

%% つまり、あるアクターについて、システム内に親アクターがいる場合、親アクターが次に生成する番号は自分の番号よりも大きい、ということにより、次に生成するアクターの名前が被らないようになっている。
%% ただし、次に生成するアクターの名前は fresh でもその次に生成するアクターは fresh ではないこともある。
%% 例えば、同じ名前でかつ次の generation number も同じという2つのアクターがいた場合、まず片方のアクターが生成するアクターの名前は fresh だが、その次にもう片方のアクターがアクターを生成したとすると、名前が被ってしまう。
%% また、親アクターがシステム内に存在せずに、親の親は存在しているという場合、親の親が次に生成するアクターの名前は被らないが、その子アクターが次に生成する名前は被ってしまう可能性がある。(図？)

Thus, to prove \textit{gen fresh preservation} proposition that \texttt{gen\_fresh} is preserved between transitions, it is necessary to use \texttt{chain} and \texttt{no\_dup} as hypotheses.
%% The proof is by ...
%% 以上のように gen\_fresh だけでは gen\_fresh を導けないので、gen\_fresh の証明には chain と no\_dup の性質が必要になる。

\begin{lemma}{gen fresh preservation}
\begin{displaymath}
  \begin{array}{l}
    \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
    \quad \texttt{chain}(c) \wedge \texttt{gen\_fresh}(c) \wedge \texttt{no\_dup}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \\
    \quad \texttt{gen\_fresh}(c')
  \end{array}
\end{displaymath}
\end{lemma}

\subsection{no\_dup}
We define \texttt{no\_dup} predicate that all actor names in the given configuration are unique.
This is the property we have to prove.
\texttt{no\_dup} is defined as the following.

\begin{displaymath}
  \begin{array}{l}
    \texttt{no\_dup}(c) := \\
    \quad \forall a \in \texttt{actors}(c), \texttt{name}(a) \notin
    \texttt{names}(\texttt{actors}(c) \setminus \{a\})
  \end{array}
\end{displaymath}

We proved \textit{no dup preservation} property defined as the following.
It represents that if the actor names in the configuration is not duplicate and the next generated actor name is fresh, then \texttt{no\_dup} holds in the next configuration.

\begin{lemma}{no dup preservation}
\begin{displaymath}
  \begin{array}{l}
    \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
    \quad \texttt{gen\_fresh}(c) \wedge \texttt{no\_dup}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \texttt{no\_dup}(c')
  \end{array}
\end{displaymath}
\end{lemma}

\subsection{uniqueness}
Then, we start to prove name uniqueness.
First, we prove trans invariant preservation that trans invariant is preserved between transitions.
This is obvious by chain preservation, gen fresh preservation and no dup preservation.
\begin{lemma}{trans invariant preservation}
  \begin{displaymath}
    \begin{array}{l}
      \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
      \quad \texttt{trans\_invariant}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \\
      \quad \texttt{trans\_invariant}(c')
    \end{array}
  \end{displaymath}
\end{lemma}

Next, we prove that if trans invariant holds in initial configuration, trans invariant holds after arbitrary transitions.

%% 次に初期状態について trans\_invariant が成り立っていれば、任意回の遷移後も trans\_invariant が成り立つということをを証明する。

\begin{lemma}{trans invariant preservation star}
  \begin{displaymath}
    \begin{array}{l}
      \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
      \quad \texttt{trans\_invariant}(c) \wedge c \overset{l}{\leadsto\star} c' \Rightarrow \\
      \quad \texttt{trans\_invariant}(c')
    \end{array}
  \end{displaymath}
\end{lemma}
$c \overset{l}{\leadsto\star} c'$ represents reflexive transitive closure of transition.
The proof is by induction of reflexive transitive closure of transition and trans invariant preservation.

Finally, we can prove name uniqueness.
\begin{theorem}{name uniqueness}
  \begin{displaymath}
    \begin{array}{l}
      \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
      \quad \texttt{trans\_invariant}(c) \wedge c \overset{l}{\leadsto\star} c' \Rightarrow \texttt{no\_dup}(c')
    \end{array}
  \end{displaymath}
\end{theorem}
This is obvious by trans invariant preservation star because \texttt{no\_dup} is in \texttt{trans\_invariant}.
