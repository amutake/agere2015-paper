\section{semantics}

Actario では

以下のように定義する。

\begin{figure}[t]
  \begin{displaymath}
    \begin{array}{rclcl}
      c & \in & \textit{Configuration} & =   & \textit{InFlight} \times \textit{Actor} \\
      a & \in & \textit{Actor}  & =   & \textit{Name} \times \textit{Actions} \times \mathbb{N} \\
      n & \in & \textit{Name}   & ::= & \textsf{toplevel}(s) \mid \textsf{generated}(g, n) \\
      m & \in & \textit{Message} & =  & \textit{Name} + \textit{PrimVal} + \\
        &     &                 &     & \textit{Message} \times \cdots \times \textit{Message} \\
      i & \in & \textit{InFlight} & = & \textit{Name} \times \textit{Name} \times \textit{Message} \\
      b & \in & \textit{Behavior} & = & \textit{Message} \rightarrow \textit{Actions} \\
      \alpha & \in & \textit{Actions} & ::= & \textsf{send}(n, m, \alpha) \\
        &     &                 &   | & \textsf{new}(b, \kappa) \\
        &     &                 &   | & \textsf{self}(\kappa) \\
        &     &                 &   | & \textsf{become}(b) \\
      \kappa & \in & \textit{Name} \rightarrow \textit{Actions} & & \\
      g & \in & \mathbb{N} & &
    \end{array}
  \end{displaymath}
  \caption{Configuration}\label{fig:config}
\end{figure}

操作的意味論を labeled transition system として形式化する。
ラベルとして receive, send, new, self の4つを用意する。

\begin{lstlisting}
  Inductive label :=
  | Receive (to : name) (from : name) (content : message) (* `to` receives a message `content` from `from` *)
  | Send (from : name) (to : name) (content : message)    (* `from` sends a message `content` to `to` *)
  | New (child : name)                                    (* an actor named `child` is created *)
  | Self (me : name).                                     (* `me` gets own name *)
\end{lstlisting}

\texttt{Receive (to : name) (from : name) (content : message)} は to という名前のアクターが from という名前のアクターからのメッセージ content を受け取ったということを表す。
\texttt{Send (from : name) (to : name) (content : message)} は from という名前のアクターが to という名前のアクターに向けてメッセージ content を送ったということを表す。
\texttt{New (child : name)} は child という名前の新しいアクターを生成したということを表し、
\texttt{Self (me : name)} は me という名前のアクターが自分自身の名前を読みだしたということを表す。

このラベル一つ一つに対応した意味論は図\ref{semantics}にある。
receive はメッセージ待ち状態にあるアクターが、自身に向けて送られたメッセージを受け取り、アクションの列を生成する遷移である。
send はあるアクターが他のアクターに向けてメッセージを送る遷移。
...
これを Coq 上で定義すると図\ref{coq:semantics}のようになる。ほとんどそのままだが集合の代わりにリストを使っている。なぜならば...

\begin{figure*}[t]
  \begin{displaymath}
    \begin{array}{rcll}
      (I \uplus \{(n_{\textrm{to}}, n_{\textrm{from}}, m)\}, A \cup \{(n_{\textrm{to}}, \textsf{become}(b), g)\}) &
      \overset{\textsf{receive}(n_{\textrm{to}}, n_{\textrm{from}}, m)}{\leadsto} &
      (I, A \cup \{(n_{\textrm{to}}, b(m), g)\}) &
      \textsc{(Receive)} \\

      (I, A \cup \{(n_{\textrm{from}}, \textsf{send}(n_{\textrm{to}}, m, \alpha), g)\}) &
      \overset{\textsf{send}(n_{\textrm{from}}, n_{\textrm{to}}, m)}{\leadsto} &
      (I \uplus \{(n_{\textrm{to}}, n_{\textrm{from}}, m)\}, A \cup \{(n_{\textrm{from}}, \alpha, g)\}) &
      \textsc{(Send)} \\

      (I, A \cup \{(n, \textsf{new}(b, \kappa), g)\}) &
      \overset{\textsf{new}(n')}{\leadsto} &
      (I, A \cup \{(n, \kappa(n'), g + 1), (n', \textsf{become}(b), 0)\}) & \\
      & & \hfill \textrm{where}\ n' := \textsf{generated}(g, n) &
      \textsc{(New)} \\

      (I, A \cup \{(n, \textsf{self}(\kappa), g)\}) &
      \overset{\textsf{self}(n)}{\leadsto} &
      (I, A \cup \{n, \kappa(n), g\}) &
      \textsc{(Self)}
    \end{array}
  \end{displaymath}
  \caption{labeled transition semantics}\label{fig:semantics}
\end{figure*}
