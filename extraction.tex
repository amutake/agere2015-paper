\section{Extraction}
Extraction is a Coq feature which enables to convert Coq programs to the programs of other languages.
Normal Coq can extract programs to OCaml, Haskell, and Scheme.
If we want to extract to other languages or use custom extraction algorithm, we have to implement it as plugins or patches.
Actario has custom extraction mechanism for the programs using Actario.
It can extract to Erlang.
It is not proven that the extraction mechanism does not change the meanings of Actario programs and Erlang programs.

\subsection{Data Types}

Values of algebraic data types are extracted to tuple with label.
Value constructor is extracted to label, and arguments are extracted to the second and the following elements of the tuple.
Figure \ref{coq:adt} is an example of extraction of the natural number type.

\begin{figure}[t]
  \begin{lstlisting}
    (* Inductive nat :=  *)
    (* | O : nat         *)
    (* | S : nat -> nat. *)

    O (* => {o} *)
    S (S (S O)) (* => {s, {s, {s, o}}} *)
  \end{lstlisting}
  \caption{example of extraction of algebraic data types}\label{coq:adt}
\end{figure}

However, actions of actors, for example \textsf{send}, \textsf{new}, \textsf{self}, \textsf{become} and \texttt{behavior} are implemented as value constructor of \texttt{actions} and \texttt{behavior} type
We handle these constructors corresponding syntax of Erlang, as special
ただし、アクターモデル特有である動作、例えば send, new, self, become, receive は、Actario では\texttt{actions}, \texttt{behavior} 型の値コンストラクタとして実装されているので、これだとただのタプルのデータとして抽出されてしまう。
このようなアクションは Erlang では構文または関数となっているため、このようなアクションだけを特別扱いして、対応する Erlang のものに変換する必要がある。

例えば、以下の Actario を用いた Coq のコードは、

\begin{lstlisting}
CoFixpoint behvA :=
  receive (fun msg =>
    match msg with
      | name_msg sender =>
        me <- self;
        sender ! name_msg me;
        become behvA
      | _ =>
        child <- new behvB;
        child ! msg;
        become behvA
    end)
\end{lstlisting}

以下のように抽出されるようにする。

\begin{lstlisting}
behvA() ->
  receive Msg -> case Msg of
    {name_msg, Sender} ->
      Me = self(),
      Sender ! {name_msg, Me},
      behvA()
    _ ->
      Child = spawn(fun() -> behvB() end),
      Child ! Msg
      behvA()
  end.
\end{lstlisting}

\subsubsection{Name}
名前はプログラマが自分でコンストラクタから作るということはしないので、すべてが変数に格納されている。
なので Erlang に変換すると変数になっている。
Actario で書いたプログラムの name 型の変数には Actario での name 型の値に束縛されているが、Erlang に変換したあとのプログラムの対応する変数は Erlang のプロセスIDに束縛されている。
